# 메소드 이름으로 쿼리 생성

spring data jpa는 메소드 이름을 분석해서 JQPL 쿼리를 실행해주는 기능을 제공한다.

만약 이름과 나이를 기준으로 회원을 조회하려면?

```java
public List<Member> findByUsernameAndAgeGreaterThan(String username, int age) {
        return em.createQuery("select m from Member m where m.username = :username
        and m.age > :age")
        .setParameter("username", username)
        .setParameter("age", age)
        .getResultList();
}
```

순수 JPA를 사용하면 위 코드와 같이 직접 상황에 맞는 JPQL을 작성해주어서 원하는 값을 디비에서 찾아야 한다.

하지만 위와 같이 간단한 CRUD 작업은 spring data jpa에서 대신 할수 있도록 기능이 구현되어 있다.

```java
public interface MemberRepository extends JpaRepository<Member, Long> {
    List<Member> findByUsernameAndAgeGreaterThan(String username, int age);
}
```

> 스프링 데이터 JPA는 메소드 이름을 분석해서 JPQL을 생성하고 실행해준다.
> 하지만, 단점도 존재하는데 파라미터나 조건이 많아지면 메서드 이름이 너무 길어진다는 것과
> 이름이 정확이 맞아 떨어져야 실행된다는 제약 조건이 있다.

## 쿼리 메소드 필터 조건

스프링 데이터 JPA 공식 문서 참고: (https://docs.spring.io/spring-data/jpa/docs/current/ reference/html/#jpa.query-methods.query-creation)

## 스프링 데이터 JPA가 제공하는 쿼리 메소드 기능

* 조회: find...By ,read...By ,query...By get...By,
    https://docs.spring.io/spring-data/jpa/docs/current/reference/html/ #repositories.query-methods.query-creation
    예:) findHelloBy 처럼 ...에 식별하기 위한 내용(설명)이 들어가도 된다.
    find...By(뒤에 아무것도 없음)를 하면 특정 엔티티를 모두 조회한다.
* COUNT: count...By 반환타입 long
* EXISTS: exists...By 반환타입 boolean
* 삭제: delete...By, remove...By 반환타입 long 
* DISTINCT: findDistinct, findMemberDistinctBy 
* LIMIT: findFirst3, findFirst, findTop, findTop3
    https://docs.spring.io/spring-data/jpa/docs/current/reference/html/ #repositories.limit-query-result

> 참고: 이 기능은 엔티티의 필드명이 변경되면 인터페이스에 정의한 메서드 이름도 꼭 함께 변경해야 한다. 그렇지 않으면 애플리케이션을 시작하는 시점에 오류가 발생한다.
> 이렇게 애플리케이션 로딩 시점에 오류를 인지할 수 있는 것이 스프링 데이터 JPA의 매우 큰 장점이다.

# JPA NamedQuery

JPA의 NamedQuery를 호출할 수 있음

## @NamedQuery 어노테이션으로 Named 쿼리 정의

```java
@Entity
    @NamedQuery(
            name="Member.findByUsername",
            query="select m from Member m where m.username = :username")
public class Member {
    ...
}
```

위처럼 엔티티 위에 @NamedQuery 어노테이션으로 정의를 하고

## JPA를 직접 사용해서 Named 쿼리 호출

```java
public class MemberRepository {
      public List<Member> findByUsername(String username) {
          ...
          List<Member> resultList =
              em.createNamedQuery("Member.findByUsername", Member.class)
                  .setParameter("username", username)
                  .getResultList();
    } 
}
```

>순수 JPA에서는 위처럼 createNamedQuery() 메서드로 호출이 가능하다.

## 스프링 데이터 JPA로 NamedQuery 사용

```java
@Query(name = "Member.findByUsername")
List<Member> findByUsername(@Param("username") String username);
```
위처럼 JPA 인터페이스에 정의된 메서드에 @Query() 에너테이션으로 NamedQuery와 매핑이 가능하다.

하지만, spring data jpa는 @Query 를 생략하고 메서드 이름만으로 Named 쿼리 호출이 가능하므로 NamedQuery 기능은 거의 사용할 일이 없다.
그냥 이런게 있구나 정도로만 알고 있자.

## 스프링 데이터 JPA로 Named 쿼리 호출

```java
public interface MemberRepository extends JpaRepository<Member, Long> {
      List<Member> findByUsername(@Param("username") String username);
}
```

> 위처럼 @Query() 에너테이션이 없더라도 1순위로 엔티티 클래스에서 @NamedQuery를 찾아서 실행한다.

* 스프링 데이터 JPA는 선언한 "도메인 클래스 + .(점) + 메서드 이름"으로 Named 쿼리를 찾아서 실행
* 만약 실행할 Named 쿼리가 없으면 메서드 이름으로 쿼리 생성 전략을 사용한다.
* 필요하면 전략을 변경할 수 있지만 권장하지 않는다.
참고: https://docs.spring.io/spring-data/jpa/docs/current/reference/html/ #repositories.query-methods.query-lookup-strategies

> @NamedQuery()나 @Query()의 가장 큰 장점은 쿼리에 오타가 있으면 `애플리케이션 로딩 시점에 에러`를 생성한다는 점이다!

> 참고: 스프링 데이터 JPA를 사용하면 실무에서 @NamedQuery를 직접 등록해서 사용하는 일은 드물다. 대신 @Query 를 사용해서 리파지토리 메소드에 쿼리를 직접 정의한다.

# @Query, 리포지토리 메소드에 쿼리 정의하기

## 메서드에 JPQL 쿼리 작성

```java
public interface MemberRepository extends JpaRepository<Member, Long> {
    @Query("select m from Member m where m.username= :username and m.age = :age")
    List<Member> findUser(@Param("username") String username, @Param("age") int age);
}
```

> 위 코드처럼 jpa 인터페이스 메서드에 @Query 에너테이션으로 바로 쿼리를 지정해줄 수 있으며 위 기능을 실무에서 많이 사용한다!
> 위 기능도 애플리케이션 로딩 시점에 파싱을 하기 때문에 쿼리에 오타가 있으면 `애플리케이션 로딩 시점에 에러`를 생성해준다!

* @org.springframework.data.jpa.repository.Query 어노테이션을 사용
* 실행할 메서드에 정적 쿼리를 직접 작성하므로 이름 없는 Named 쿼리라 할 수 있음
* JPA Named 쿼리처럼 애플리케이션 실행 시점에 문법 오류를 발견할 수 있음(매우 큰 장점!)

> 참고: 실무에서는 메소드 이름으로 쿼리 생성 기능은 파라미터가 증가하면 메서드 이름이 매우 지저분해진다. 따라서 @Query 기능을 자주 사용하게 된다.

# @Query, 값, DTO 조회하기

## 단순히 값 하나를 조회

```java
@Query("select m.username from Member m")
    List<String> findUsernameList();
```

> 위와같은 쿼리로 Member 엔티티의 userName만 뽑아내서 리스트로 반환할 수 있다.(JPA 값 타입( @Embedded )도 이 방식으로 조회할 수 있다.)

Q: 하지만, 위처럼 하나의 컬럼만 가져오고 싶은것이 아니라 여러개의 컬럼을 조회하고 싶다면?
A: DTO를 이용해서 조회하면 된다.

## DTO로 직접 조회

```java
@Query("select new study.datajpa.dto.MemberDto(m.id, m.username, t.name) from Member m join m.team t")
  List<MemberDto> findMemberDto();
```
> 주의! DTO로 직접 조회 하려면 JPA의 new 명령어를 사용해야 한다. 그리고 다음과 같이 생성자가 맞는 DTO가 필요하다. (JPA와 사용방식이 동일하다.)

```java
  public class MemberDto {
      private Long id;
      private String username;
      private String teamName;
      public MemberDto(Long id, String username, String teamName) {
          this.id = id;
          this.username = username;
          this.teamName = teamName;
      }
}
```

